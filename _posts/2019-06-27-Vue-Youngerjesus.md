---
layout: post
title:  "Vue.js " 
date:   2019-06-25 15:46:00  +0530
commetns: true 
categories: Vue.js  
---
카카오 클레이튼 
    블록 생성시간 1초 
        How? 
    초당 트랜잭션 처리 3000 
        How? 
    트랜잭션 비용이 낮다. 
        왜 이걸 낮췄지 트랜잭션 비용을 높인 이유가 있었자나 이더리움에서 그거랑 연관시켜야겠네. 

    확장성은 어떻게 되는지(Scalability)
       얼마나 많은 일을 신속히 처리할 수 있는지가 확장성 
        (참여자가 많아지면 왜 그거에 맞게 비트코인은 블록생성시간을 늘리지않는가)
            스테일 블록(stale block): 채굴자에 의해 올바른 형식으로 채굴된 블록이지만 현재의 블록체인에 업데이트 되지 못한 블록을 말함
            블록이 동시에 생성된 경우 한개는 버려야함 그 버리는 기준은 가장 긴 체인을 기준 
            블록 생성시간이 짧아지면 블록이 많이 생성될 수 있고 동시에 생성될 가능성이 높아직고 버려질 블록이 많아진다.  

       비트코인과 이더리움은 확장성 문제가 많다. (왜 안 좋은가)

        확장성을 따지는 기준이 TPS + Block Interval을 기준으로 따진다. 
            Transaction per Second 초당 몇개의 거래처리를 말한다.
                트랜잭션의 종류에 따라서 달라질 수 있다. 스마트 컨트랙트는 더 많은 연산을 요구하기때문에 시간이 더 걸리고 
                같은 기능을 수행하는 컨트랙트라고 해도 실제 코드 구현 형태에 따라 더 많은 연산을 요구하고 더 오랜 시간이 걸릴 수 밖에 없다.

            Block Interval; 블록 생성 시간을 말한다. 
                트랜잭션이 처리되어 저장되는데에 걸리는 최소 대기시간을 말한다. 
            
            (확정시간 = N(신뢰도) * 블록 생성시간 
                블록체인 특성 상 내 트랜잭션이 최신 블록에 포함되었다고하여 이게 안전하게 저장되었다고 확신할 수 없다. 
                포크의 가능성은 언제나 존재하고 내 트랜잭션이 메이저포크에 들어있다는 것을 확신하기까지 기다려야한다. 
                대부분 블록체인에서 메이저 포크에 들어있다는 보증은 없고 추측만한다. 이 정도 횟수의 컨펌이 되었다면 트랜잭션이 무효화 되는일은 없을거라는 생각하에 

                왜 알 수 없지? 
            )

            Visa TPS: 1700 
            비트코인 TPS: 7 (현실적으로는 2개에서 3개) 
            이더리움 TPS: 20     

            Block Interval
                비트코인: 10분 
                이더리움 15초 ~ 20초
            
            블록당 트랜잭션 개수
                이더링무 15 * 20 = 300 Transaction이 한 블록당 트랜잭션에 들어간다. 
                블록당 트랜잭션 개수가 많으면 어떻게 되는건가
                (최대로 내가 요청한 트랜잭션이 처리될려면 블록이 생성될떄까지 기다려야 할 수 있다라는게 무슨말일까 앞에 쌓인 트랜잭션부터 먼저 처리되지 않으띾) 
                (평균대기시간 = 블록생성시간 / 2) why? 
                내 앞에 트랜잭션이 엄청많다면 어떻게 될까 

            기존의 블록체인 문제점
                참여하는 노드가 많다고해서 빨라지지가 않는다. 
                기존 서버는 사용자가 많아지면 서버를 여러개두면서 빨리 처리하려고한다. 
                *제일 느린 노드에 맞게 하향 평준화가 된다라는 소리는 왜 이렇게 되는걸까? 
                (모든 참여자가 합의를 도출해야하니까 정보의 검증은 가장 느린 노드의 속도에 맞출 수 밖에 없다)
                비트코인 이더리움 
                    네트워크 속도느림 
                    많은양의 트랜잭션 처리하는게 힘듬 


    Finality 
        변경 불가능한 최종적인 상태를 말한다. 
        블록이 Final 하다라는건 블록에 담긴 거래가 바뀔 수 없다는 걸 보증한다. 

        비트코인과 이더리움은 이 최종성 확정성이 부족하다.
            최종성은 완벽한 보증이아니라 확률론적 최종성만 제공한다. 이게 문제다. 

            비트코인 기준 Finality까지의 평균시간 60분 (6번의 검증 )
            이더리움 기준 불록 채굴시간 15초(블록 생성 시간 ) 6분(25번의 검증) 

            *메이저 체인에 연결되었는지를 확인하는 방법이 있으면 되지않나? 이 문제는

    Fork
        블록들의 연결이 두개 이상으로 갈라지는 걸 말한다.
        포크의 발생 이유는 독립적으로 개개인이 채굴이 가능하기 때문에 
        (이게 왜? )
        (작업증명 방식으로 블록을 채굴한다. 비트코인과 이더리움은 경쟁적으로 문제는 동시에 블록을 채굴할 때 
        이떄 블록이 두개가 올라오게되고 분기가 발생하게 된다)

        *분기가 일어날경우 갈라진 블록에 대해서 다시 재전송하고 그런 기능은없나 TCP에서도 reliable한 data transfer을 위해서 재전송하는거 있었잖아. 
            다시 다운되는게 있는거같은데 
        블록이 연결될떄 부모의 블록해쉬주소를 가지고 있기떄문에 연결된다.  

        *main chain을 정하는 룰 Longest chain rule 이걸 악용할떄 51% 파워 컴퓨팅 능력을 가지면 된다는게 이게 뭔소리지  어짜피 연산은 알아서 해주는게 아닌가 
            다른 노드들에게 전파를 안하고 51%니까 자기들끼리 합의를 보고 연결시킨다는건가 
 
    solidiity 지원 

    truffle 지원
    
기존의 블록체인의 문제점과 클레이튼     
Tool
    Wallet

    IDE

    scope 

합의 
    어떤 합의알고리즘을 사용해서 문제점을 해결하는지 

    합의 알고리즘은 여러개가 있고 Public , Private에 따라서 다르다 - (왜? ) 
    Public 블록체인     
        Pow, Pos 

    Privae 블록체인 
        pBFT, Raft 
        public 블록체인이 private 블록체인보다 더 편하게 합의에 도달 할 수 있다. (일단 둘의 차이는 합의에 참가하는 노드 수가 다를거같다)
        BFT - 참여 노드 수 제한 / 성능 높임 (참여한 노드자체가 어느정도의 신뢰성을 가지고 있는거니까 문제 될 부붕는 없다.)
        참여 노드 수가 제한된다라는건 투명성을 저하시키고, 소규모집단에서의 블록체인을 쓴다라는건 분산화가 약화된다라는 의미
        
        클레이튼의 경우 이런 문제를 해결하는 IBFT 알고리즘(이스탄불 비잔티움 결함 허용)
        public 블록체인의 장점과 결합해서 사용한다라는 믿음을 통한다고 한다. 엔터프라이즈급 성능과 안정성을 제공한다. (이걸 어떻게 하는데) 
        공개를 통한 개인적인 합의 신뢰 모델 
            합의를 달성하는 소수 private 노드와 
            블록 생성 결과 접근 및 검증하는 노드 이렇게 구성돠어있다. 

        IBFT 세부내용 
            Propose - pre-prepare - prepare - commit - reply
            reply전까지 3단계가 있다. 
            라운드 로빈 방식을 사용해서 라운드마다 Proposer(제안자)를 뽑는다. 그리고 나머지 합의 노드들은 Validator가 된다. 
            Validator1 Validator2 Validator3이렇게 
            Validator3에 x가 되있다라는건 합의를 못하는 상태, 네트워크가 끊어졌거나, 악의적인 행동을 했거나의 문제가 생긴 상태를 말한다.
            
            Propose 단계
                합의 노드 중 하나가 Propser로 선택을한다. (라운드 로빈 방식으로)
            pre-prepare 
                Proposer가 블록을 만들고 다른 Validator들에게 제안을 하게 된다. (어떤 제안을 말하는건데)
            prepare
                Proposer에게 메시지를 받게되면 자신을 제외한 다른 노드들에게 잘 받았다고 제시하게된다. 
                여기서 Validator3은 fault가 일어난 상태이므로 어떠한 전송도 하지못한다. 
                prepare가 끝나면 몇개의 노드가 지금 합의에 참여하는지 알 수 있다. (Validator 개개인이 몇개의 알림을 받았는지 생각해보면된다. )
            commit 
                Proposer들에게 받은 제안을 수락할건지 다른 노드들과 통신하며 결정한다. 
                3분의2이상이 승락을 하면 블록 승락을한다. 이렇게되면 비트코인과 이더리움과는 다르게 finality 부재가 없고 변경 불가능한 데이터가 저장된다.   
                이 방식의 문제점이라고하면 합의 노드가 많아질수록 통신의량은 기하 급수적으로 많아진다.
                근데 BFT방식에서는 합의에 참여하는 노드를 일부만 뽑아서 하기떄문에 통신량이 많지않다. (뽑는 기준은 어떻게 되는데)

블록 생성 전파 
    블록 생성 사이클
        클레이튼의 블록생성주기는 라운드라고한다. 
        새로운 블록을 생성하고 끝내는 즉시 새로운 라운드가 시작된다. 
        블록의 생성시간은 약 1초정도가 된다.
    
    제안자와 위원회 선택(Proposer and Committee Selection)
        제안자를 무작위(randomly) & 결정적(deterministically)으로 Governance Council노드들 중 뽑는다. 
        Governance Council노드들은 합의 노드들 이라고 보면된다. 좀 더 자세히 설명하면 
        각각의 합의 노드가 가장 최근의 블록헤더에서 파생된 난수를 사용해서 자기가 라운드에 선택되었는지를 증명한다./(이게 제안자를 말하는건지 위원회를 말하는건지)
        (미리 최근의 블록헤더에서 파생된 난수를 보는 방법은 없는거지?) 
        위원회들이 Validator노드들이다. 

        이떄 제안자들은 공개키를 통한 입증가능한 암호증명을 쓰고 위원회들도 자신이 뽑혔다는 증거인 암호증명을 제안자에게 보낸다. (암호증명은 믿을만한건가 어떤거지)

        이 과정이 끝나면 누가 제안자고 누가 위원회인지 파악이된다. 
        제안자가 트랜잭션 풀에서 트랜잭션을 선택하고 정렬해서 블록을 만들게 된다. 그리고 위와같은 IBFT과정을 통해서 합의에 도달하게 되면 블록에 저장한다. 

    블록전파 
        제안된 블록은 성공적으로 완료되기 위해서 위원회 멤버들의 3분의2이상이 동의해야하고 
        합의에 도달하면 새로운 블록이 모든 합의노드들에게 전달이 되고 라운드가 끝이난다.                 
        이제 모든 노드들에게 알려져야하는데 그걸 프록시 노드가 엔드포인트 노드들에게 전달을 함으로써 알리게된다. 

클레이튼 네트워크 구조
    전체 네트워크안에 Core Cell Newtork가 존재하고 
    Core Cell을 둘러싸는 Endpoint Node Network가 존재한다. 
    아게 계층구조로 연결되어있는거같다.  (CNN과 ENN은 각각 변하는거인가 매 라운드마다?) 
    Core Cell은 한개의 CN(한명의 참여자를 말하지)와 여러개의 PN으로 구성한다. 
    CN은 계속 통신할 수 있고 빠르게 통신할 수 있도록 연결되어 있다 (TCP로 지속적 연결을 말하는건가?)
    CN은 외부와 접촉할 수 없고 굉장히 Private환 환경에 놓여있게된다. (몰래 다른쪽과 통신하는게 안된다라는걸 의미)

    (EN은 CN과 소통하기위해서는 PN을 거쳐야하는건가? Guard 역할을 하는건가?)
    (블록이 생성되면 그걸 모든 노드들에게 전파되어야하는데 EN끼리 그런 사실을 전달받는것보다는 PN으로부터 전달받는게 안전 )
    
    CN BootNode, PN BootNode EN BootNode들은 새로 들어온 노드들이 등록을 하는곳 
    CN은 공개가 되지않고, PN과 EN은 공개가된다. 

    EN이 되는 조건은 따른게 없다. 
    CNN: Consensus Node Network 
    PNN: Proxy Node Network 
    ENN: Endpoint Node Network 

코어 셀(Core cell)
    메인 네트워크가 런칭이되면 몇십대정도가 유지될 것 

    사용자가 많아지는 경우 확장이 필요할 떄
        일반적인 경우에는 서버를 늘리고 Request를 분할처리한다.
        블록체인의 경우에는 노드가 늘어난다고 성능이 늘어나진 않늗나
        클레이튼은 노드 자체의 성능을 올린다. (cpu, ram 이런것들 ) (왜 이런 결정을 했지 )
        (이것도 참여자가 많아지면 어느정도 한계가 있는거 아닌가? )
        (합의 노드츼 참여조건을 달성한 컴퓨터를 51%사게 되면 어떻게 되는가)

        CN(합의 노드의 참여조건)
        - Physical core가 40개 이상 
        - 256GB RAM 
        - 1년치의 데이터 약 14TB 저장 
        - 10G 네트워크 

        참고로 하나의 CN이 성능이 압도적으로 좋다고해서 처리속도가 빨라지는건 아니다 (나머지 노드들은 자기 스펙대로 움직이니까)
        성능을 올릴라면 전체의 스펙이 올라가야한다. 
        
        PN을 둔 이유자체가 CN의 수는 제한되어있어서 연결도 얼마 못한다. 그 역할을 PN이 되신 해주는것 (새로운 블록의 생성들을 알려주는것 뿐아니라, EN으로부터 받은 트랜잭션처리들도 CN으로 넘겨주는 작업을한다.)
        (if CN이 EN과 직접적 연결이 된다고 가정할 경우에 커넥션이 계속적으로 늘어나면 성능에 영향을 미치니까 합의속도가 느려지는 상황이 생긴다)
        (커넥션이 걸림돌이 되어선 안된다.) (PN은 확장성과 CN의 안정성을 위한것 )

서비스 체인 
    메인넷과 연결되는 독립적인 블록체인 
    메인넷과 서비스 체인의 연결이 자유로운것은 아니다. 오직 제한된 트랜잭션만을 사용하는게 가능하다. 
    (운영이 어떻게 되는지 합의는 어떻게 이르지?) 
    독립된 서비스 공간을 구축하고 필요할 때 메인 네트워크에 신뢰를 고정시킨다. 
    클레이튼의 서비스체인안에서는 트랜잭션 수수료를 안받게 할 수 있어서 자기가 원하는 환경을 구축하는게 가능하다.      
    (그럼 거의 모든 서비스들이 다 서비스체인을 이용하지않을까?)
    
    언제 쓰이냐면 
        특별한 노드환경에서 설정 
        Private 블록체인으로 쓰고싶을때 보안수준을 맞추기 위해서 
        많은 처리량을 요구해서 메인넷 배포하기에는 적합하지 않은 경우 
         

이더리움과 클레이튼 차이는  
    이더리움 
        단일 네트워크로 누구나 블록을 만들 수 있고 블록을 만들었을 경우에 가장 많이 전파해야한다. 그래서 블록을 추가하도록 만들어야한다. 
        이게 Pow(작업증명)
        어떠한 노드든지 블록을 만들고 전파할 수 있기때문에 정보를 얻기 위해서는 가능한 많은 연결을 만들어야한다. 
        마이닝 노드: 블록을 쓰고 네트워크에 전파한 노드 

    클레이튼 
        단일 네트워크가 아닌 Two Layer Architecture Trust Model이다 
        EndPoint Newtork가 Core Cell Network에 연결해서 빠르게 데이터를 읽거나 쓰는게 가능하다. 
        이더리움과 다르게 불특정한 누군가가 블록을 만드는게 아니라 매 라운드마다 합의 노드들 중 하나가 뽑혀서 블록을 쓴다. (블록을 쓰는 노드가 누군지 안다)
        그렇기 때문에 Endpoint Node들은 Core Cell에 붙어있는 구조를 가진다. 
        그래야 신뢰도가 높은 정보를 받을 수 있다. Core Cell에게 밭는 정보가 옆에있는 EndPoint Node들에게 받는 정보보다는 신뢰도가 높다. 

        우리가 어플리케이션을 만들떄 서버들을 구축하게 된다. java, sql, 개인서버들을 운영할경우 직접적인 Core Cell과 연결시키기 어려우니까 EndPoint와 먼저 연결해야한다. 
        내 컴퓨터를 EndPoint Node들로 만들거나, 아니면 신뢰가능한 EndPoint Node들과 연결시켜서 정보를 받거나 쓰거나 둘 중 하나다. 
        내 컴퓨터를 EndPoint Node들로 만들려면 클레이튼 네트워크의 블록들과 동기화 문제를 해결해야한다.  
        내가 단순하게 클레이튼 메인 네트워크와 연결해서 데이터를 읽어오는 작업만 할거라면 EndPoint Node를 만들 필요가 없고 그냥 연결해서 사용하면 된다.

        이더리움과 다르게 메이넷과 부분적으로 소통할 수 있으며 독립적인 서비스를 구축하는 서비스 체인이 존재한다. 
          

------------------------ BApp 실습 ------------------------

BApp = Blockchain Application 
    3초안에 맞추면 무료로 0.1 Klay 지급 

    로그인 방식이 특이하다
        Key Store과 비밀번호를 통해서 로그인 
    
    Contract주소와 이벤트 잔액을 공개함으로써 투명성을 보장

    아더리움의 web3.js 와 비슷한 클레이튼의 caver.js를 이용하며
    
    스마트컨트랙트 언어로 solidity를 지원한다. 

    트러플 프레임워크를 사용한다. 

    Tools 
        Smart Contract 테스트를 위한 IDE를 사용하고 
        계정관리를 위한 Wallet 
        트랜잭션 조회를 위한 Scope 검색 엔진을 사용 

Klayton Wallet & 계정관리 
    블록체인 네트워크를 이용하기 위한 계정을 만들어야한다 그게 Wallet 
    https://baobab.wallet.klaytn.com/
    여기서 만든 계정은 Testnewtork 여기서 사용하는 klay는 실제 가치가 없다.

    KeyStore file , 비밀번호 만들기 
    비밀번호 입력하고 keyStore 파일 다운로드 한다 

    트랜잭션 서명을 위한 Private Key를 다른데다가 저장해야한다. 

    Gas price
        합의 노드들에게 트랜잭션 처리 비용을 내는것 이더리움과는 다르게 고정적이다 
    Gas Limit 
        트랜잭션 처리 한도 비용을 말한다. 무한반복문같은 작업을 막기 위한것 Gas Limit을 초과할경우 그 작업은 멈추게된다. 
    
    Ston은 클레이 화페 단위
        peb 10^9을 말하고 klay는 peb의 10^18 

Klayton IDE 
    https://ide.klaytn.com/

    Solidity를 이더리움 네트워크와 연결하는게 아니라 Klaytn 네트워크와 연결해서 쓰인다. 

    DevNode - 개발용 테스팅을 위한것 계정을 임의로 만들어서 쓴다 

    컨트랙으로 함수를 만들자  
        컨트랙으로 klay 송금 
        klay 잔고를 확인하는것 
    
    컨트랙 배포한담에 어떻게 쓰는건가 
    컨트랙 소유자가 되는거
    
    (블록이 계속생성되면 네트워크에 괜찮은건가)
scope 
    klaytn 정보와 트랜잭션또느 컨트랙 정보들을 볼 수 있다  
    https://baobab.scope.klaytn.com/

환경설정 
    Node.js 
    NPM
    트러플 프레임워크 
    Vscode 
        
Reference: 
https://m.blog.naver.com/PostView.nhn?blogId=ehdtmdcouple&logNo=221183650560&proxyReferer=https%3A%2F%2Fwww.google.com%2F
https://baobab.wallet.klaytn.com/
https://ide.klaytn.com/
https://baobab.scope.klaytn.com/
